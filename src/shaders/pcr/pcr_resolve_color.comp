#version 460
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require
#extension GL_KHR_shader_subgroup_arithmetic : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable
#include "pcr_commons.h"

layout(binding = 0, rgba32f) uniform image2D output_image;
layout(local_size_x = shader_atomic_size_x) in;

layout(push_constant) uniform _PC { PC pc; };
layout(buffer_reference, scalar) buffer ConstantInfos { ShaderAtomic c; };
layout(buffer_reference, scalar) buffer Depths   { uint64_t d[]; }; // uint64_t to be able to hold depth and color values in a single buffer

ConstantInfos constants = ConstantInfos(pc.info_addr);
Depths depths = Depths(constants.c.depth_image_addr);

void main(){
    if(gl_GlobalInvocationID.x >= pc.size_x * pc.size_y)
        return;
    
    uint x = gl_GlobalInvocationID.x % pc.size_x;
    uint y = gl_GlobalInvocationID.x / pc.size_x;

    // laod depth and  extract color
    uint64_t depth_color = depths.d[gl_GlobalInvocationID.x];
    vec4 col;
    col.x = float((depth_color >> 24) & 0xff) / 255.;
    col.y = float((depth_color >> 16) & 0xff) / 255.;
    col.z = float((depth_color >> 8) & 0xff) / 255.;
    col.w = 1;
    imageStore(output_image, ivec2(x, y), col);
}
