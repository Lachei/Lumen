#version 460
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require
#extension GL_KHR_shader_subgroup_arithmetic : enable
#extension GL_EXT_shader_atomic_int64 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable
#include "pcr_commons.h"

layout(binding = 0, rgba32f) uniform image2D output_image;
layout(local_size_x = hash_map_size_xy.x, local_size_y = hash_map_size_xy.y) in;

layout(push_constant) uniform _PC { PC pc; };
layout(buffer_reference, scalar) buffer ConstantInfos { HashMapConstants c; };
layout(buffer_reference, scalar) buffer HashMap  { HashMapEntry d[]; };
layout(buffer_reference, scalar) buffer Occupancies { OccupancyEntry d[]; };
layout(buffer_reference, scalar) buffer Data     { DataEntry d[]; };
layout(buffer_reference, scalar) buffer EmptySkipMap{ EmptySkipEntry d[]; };
layout(buffer_reference, scalar) buffer EmptySkipInfosBuffer{ EmptySkipInfo infos[]; };

ConstantInfos constants = ConstantInfos(pc.info_addr);
HashMap hash_map = HashMap(constants.c.hash_map_addr);
Occupancies occupancies = Occupancies(constants.c.occupancies_addr);
Data data = Data(constants.c.data_addr);
EmptySkipInfosBuffer empty_skip_infos= EmptySkipInfosBuffer(constants.c.empty_infos_addr);

const bool show_hash_grid = false;
const bool show_iteration_count = false;

// taken from https://www.shadertoy.com/view/fdyXDR
// returns the shortest distance to an axis intersection
// p: position of the observer
// rd: ray direction of the observer
// delta: vec3 containing the inverses of the direction
// s: current grid size
float calc_t(vec3 p, vec3 rd, vec3 delta, float s){
    vec3 t;
    t.x = rd.x < 0. ? ((p.x*s - floor(p.x*s))/s)*delta.x
                    : ((ceil(p.x*s) - p.x*s)/s)*delta.x; 
                    
    t.y = rd.y < 0. ? ((p.y*s - floor(p.y*s))/s)*delta.y
                    : ((ceil(p.y*s) - p.y*s)/s)*delta.y; 
    
    t.z = rd.z < 0. ? ((p.z*s - floor(p.z*s))/s)*delta.z
                    : ((ceil(p.z*s) - p.z*s)/s)*delta.z; 

                    //+0.01 to get rid of a bunch of artifacts
    return min(t.x,min(t.y,t.z))+0.001;
}

// returns the intersection point with the AABB defined by b_min and b_max, code from https://www.shadertoy.com/view/wtSyRd
vec3 intersection(vec3 ray_origin, vec3 ray_dir, vec3 minpos, vec3 maxpos){
    vec3 inverse_dir = 1.0 / ray_dir;
    vec3 tbot = inverse_dir * (minpos - ray_origin);
    vec3 ttop = inverse_dir * (maxpos - ray_origin);
    vec3 tmin = min(ttop, tbot);
    vec3 tmax = max(ttop, tbot);
    vec2 traverse = max(tmin.xx, tmin.yz);
    float traverselow = max(traverse.x, traverse.y);
    traverse = min(tmax.xx, tmax.yz);
    float traversehi = min(traverse.x, traverse.y);

    if(traversehi < max(traverselow, 0.0))
        return vec3(1./0);

    return ray_origin + (traverselow + .01) * ray_dir; 
}

// adopted from https://stackoverflow.com/a/26697650
bool inside_aabb(vec3 p, vec3 b_min, vec3 b_max) {
    vec3 s = step(b_min, p) - step(b_max, p);
    return bool(s.x * s.y * s.z); 
}


// This shader implements the hash map approach for point cloud rendering

void main(){
    const float hash_bucket_delta = constants.c.delta_grid * box_per_hash_box;
    if(gl_GlobalInvocationID.x >= pc.size_x || gl_GlobalInvocationID.y >= pc.size_y)
        return;
    
    // calculate starting position and direction
    vec2 norm_dev_coords = (vec2(gl_GlobalInvocationID.xy) + vec2(.5)) / vec2(pc.size_x, pc.size_y) * 2 - 1;
    vec4 origin = pc.cam_view_inv[3]; // 4th column is the origin transformation
    vec4 dir = pc.cam_proj_inv * vec4(norm_dev_coords.x, norm_dev_coords.y, 1, 1);
    float dist = length(dir.xyz);
    dir = pc.cam_view_inv * vec4(normalize(dir.xyz), 0);
    vec4 p = origin + .1 * dist * dir;

    // calculating starting position (first intersection with the whole volume)
    // only do if not already in the bounding box
    vec3 b_min = constants.c.bounds_min;
    vec3 b_max = constants.c.bounds_max;
    if(!inside_aabb(p.xyz, b_min, b_max))
        p.xyz = intersection(p.xyz, dir.xyz, b_min, b_max);
    
    // if no intersection found exit
    if(isinf(p.x)){
        imageStore(output_image, ivec2(gl_GlobalInvocationID.xy), vec4(0));
        return;
    }

    if(show_hash_grid){ 
        // debug output
        uint h = hash_p(p.xyz, constants.c.delta_grid);
        h = (h ^ (h >> 16)) & 0xffff;
        vec4 col = vec4(sin(h * .1) * .5 + .5, sin(h * .3) * .5 + .5, sin(h * .5) * .5 + .5, 1);
        imageStore(output_image, ivec2(gl_GlobalInvocationID.xy), col);
        return;
    }

    vec3 delta = 1./max(abs(dir.xyz), 1e-3);

    HashMapEntry cur_entry;
    OccupancyEntry occupancy_entry; // only is loaded if successfully found hash map stuff
    cur_entry.key.x = box_unused;
    bool error = false;
    for(int i = 0; i < 500 && inside_aabb(p.xyz, b_min, b_max); ++i){
        float cur_delta = constants.c.delta_grid;
        
        // ---------------------------------------------------
        // Checking for empty space to skip
        // ---------------------------------------------------
        uint map_mult = constants.c.empty_space_levels; // if larger than 0 then the bucket is empty (iteration did not run until the end)
        for(; map_mult > 0; --map_mult){
            const float d = constants.c.delta_grid  * (1 << map_mult); // 1 is shifted instead of 2 in BuildHashMap.h as map_mult starts at 1
            const EmptySkipInfo info = empty_skip_infos.infos[map_mult - 1];

            i16vec3 empty_space_bucket = bucket_pos(p.xyz, d);
            uint empty_h = hash(empty_space_bucket);
            uint empty_index = hash_table_index(empty_h, info.map_size);
            EmptySkipMap empty_skip_map = EmptySkipMap(info.map_addr);
            EmptySkipEntry empty_entry = empty_skip_map.d[empty_index];
            for(int j = 0; j < 10 && empty_entry.key.x != box_unused && empty_entry.key != empty_space_bucket && empty_entry.next != NEXT_T(-1); ++j)
                empty_entry = empty_skip_map.d[empty_entry.next];

            if(empty_entry.key != empty_space_bucket) // bucket contains no data
                break;
        }

        if(map_mult > 0){
            cur_delta = hash_bucket_delta * (1 << map_mult);
        }
        else{ // space is not empty -> check further
            // ---------------------------------------------------
            // loading the bucket information, only try, if not available continue
            // ---------------------------------------------------
            i16vec3 cur_bucket = bucket_pos(p.xyz, constants.c.delta_grid);
            // check if the bucket has to be reload
            if(cur_bucket != cur_entry.key){
                uint h = hash(cur_bucket);
                uint index = hash_table_index(h, constants.c.hash_map_size);
                cur_entry = hash_map.d[index];
                for(int j = 0; j < 10 && cur_entry.key.x != box_unused && cur_entry.key != cur_bucket && cur_entry.next != NEXT_T(-1); ++j){
                    index = cur_entry.next;
                    //index %= constants.c.hash_map_size;
                    cur_entry = hash_map.d[index];
                }
                if(error) break;
                // loading the rest of the hash map info only if the block was found succesfully
                if(cur_bucket == cur_entry.key)
                    occupancy_entry = occupancies.d[cur_entry.occupancy_index];
            }

            // ---------------------------------------------------
            // checking for the contents fo the current voxel
            // ---------------------------------------------------

            // if cur_entry still is not for the current grid pos we have an empty grid
            // and can advance to the next hash bucket pos (so skipping to the next bucket pos)
            if(cur_entry.key != cur_bucket){
                cur_delta = hash_bucket_delta;
            }
            else{ // check for used bucket pos
                float small_delta = constants.c.delta_grid / box_per_hash_box;
                vec3 hash_bucket_base = bucket_base(cur_bucket, constants.c.delta_grid);
                vec3 small_base = bucket_base(bucket_pos(p.xyz, small_delta), small_delta);
                vec3 bucket_center = small_base + vec3(small_delta * .5);
                vec3 center_dir = bucket_center - origin.xyz;
                float dist = length(bucket_center - (origin.xyz + dot(center_dir, dir.xyz) * dir.xyz));
                if(check_bit(occupancy_entry, hash_bucket_base, p.xyz, constants.c.delta_grid)
                    //&& dist < 2 * small_delta 
                    ){
                    // bit set, writeout depth and return, nothing more to do
                    if(show_iteration_count)
                        imageStore(output_image, ivec2(gl_GlobalInvocationID.xy), vec4(.01) * i);
                    else{
                        uint offset = calc_bit_offset(occupancy_entry, hash_bucket_base, p.xyz, constants.c.delta_grid);
                        uint col = data.d[occupancy_entry.data_index + offset].col;
                        vec4 color = vec4(uint_col_to_vec(col), 1);
                        imageStore(output_image, ivec2(gl_GlobalInvocationID.xy), color);
                    }
                    return;
                }
            }
        }
        
        // ---------------------------------------------------
        // updating p via DDA
        // ---------------------------------------------------
        p.xyz += calc_t(p.xyz, dir.xyz, delta, 1. / cur_delta) * dir.xyz;
    }
    if(error){
        imageStore(output_image, ivec2(gl_GlobalInvocationID.xy), vec4(1,0,0,1));
        return; }
    imageStore(output_image, ivec2(gl_GlobalInvocationID.xy), vec4(0));
}
