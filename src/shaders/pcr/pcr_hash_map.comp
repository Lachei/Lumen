#version 460
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require
#extension GL_KHR_shader_subgroup_arithmetic : enable
#extension GL_EXT_shader_atomic_int64 : enable
#include "pcr_commons.h"

layout(binding = 0, rgba32f) uniform image2D output_image;
layout(local_size_x = hash_map_size_xy.x, local_size_y = hash_map_size_xy.y) in;

layout(push_constant) uniform _PC { PC pc; };
layout(buffer_reference, scalar) buffer ConstantInfos { HashMapConstants c; };
layout(buffer_reference, scalar) buffer HashMap  { HashMapEntry d[]; };
layout(buffer_reference, scalar) buffer Data     { DataEntry d[]; };

ConstantInfos constants = ConstantInfos(pc.info_addr);
HashMap hash_map = HashMap(constants.c.hash_map_addr);
Data data = Data(constants.c.data_addr);

const bool show_hash_grid = false;
const bool show_iteration_count = true;

// taken from https://www.shadertoy.com/view/fdyXDR
// returns the shortest distance to an axis intersection
// p: position of the observer
// rd: ray direction of the observer
// delta: vec3 containing the inverses of the direction
// s: current grid size
float calc_t(vec3 p, vec3 rd, vec3 delta, float s){
    vec3 t;
    t.x = rd.x < 0. ? ((p.x*s - floor(p.x*s))/s)*delta.x
                    : ((ceil(p.x*s) - p.x*s)/s)*delta.x; 
                    
    t.y = rd.y < 0. ? ((p.y*s - floor(p.y*s))/s)*delta.y
                    : ((ceil(p.y*s) - p.y*s)/s)*delta.y; 
    
    t.z = rd.z < 0. ? ((p.z*s - floor(p.z*s))/s)*delta.z
                    : ((ceil(p.z*s) - p.z*s)/s)*delta.z; 

                    //+0.01 to get rid of a bunch of artifacts
    return min(t.x,min(t.y,t.z))+0.02;
}

// returns the intersection point with the AABB defined by b_min and b_max, code from https://www.shadertoy.com/view/wtSyRd
vec3 intersection(vec3 ray_origin, vec3 ray_dir, vec3 minpos, vec3 maxpos){
    vec3 inverse_dir = 1.0 / ray_dir;
    vec3 tbot = inverse_dir * (minpos - ray_origin);
    vec3 ttop = inverse_dir * (maxpos - ray_origin);
    vec3 tmin = min(ttop, tbot);
    vec3 tmax = max(ttop, tbot);
    vec2 traverse = max(tmin.xx, tmin.yz);
    float traverselow = max(traverse.x, traverse.y);
    traverse = min(tmax.xx, tmax.yz);
    float traversehi = min(traverse.x, traverse.y);

    if(traversehi < max(traverselow, 0.0))
        return vec3(1./0);

    return ray_origin + (traverselow + .01) * ray_dir; 
}

// adopted from https://stackoverflow.com/a/26697650
bool inside_aabb(vec3 p, vec3 b_min, vec3 b_max) {
    vec3 s = step(b_min, p) - step(b_max, p);
    return bool(s.x * s.y * s.z); 
}


// This shader implements the hash map approach for point cloud rendering

void main(){
    const float hash_bucket_delta = constants.c.delta_grid * box_per_hash_box;
    if(gl_GlobalInvocationID.x >= pc.size_x || gl_GlobalInvocationID.y >= pc.size_y)
        return;
    
    // calculate starting position and direction
    vec2 norm_dev_coords = (vec2(gl_GlobalInvocationID.xy) + vec2(.5)) / vec2(pc.size_x, pc.size_y) * 2 - 1;
    vec4 origin = pc.cam_view_inv[3]; // 4th column is the origin transformation
    vec4 dir = pc.cam_proj_inv * vec4(norm_dev_coords.x, norm_dev_coords.y, 1, 1);
    float dist = length(dir.xyz);
    dir = pc.cam_view_inv * vec4(normalize(dir.xyz), 0);
    vec4 p = origin + .1 * dist * dir;

    // calculating starting position (first intersection with the whole volume)
    // only do if not already in the bounding box
    vec3 b_min = constants.c.bounds_min;
    vec3 b_max = constants.c.bounds_max;
    if(!inside_aabb(p.xyz, b_min, b_max))
        p.xyz = intersection(p.xyz, dir.xyz, b_min, b_max);
    
    // if no intersection found exit
    if(isinf(p.x)){
        imageStore(output_image, ivec2(gl_GlobalInvocationID.xy), vec4(0));
        return;
    }

    if(show_hash_grid){ 
        // debug output
        uint h = hash_p(p.xyz, constants.c.delta_grid);
        h = (h ^ (h >> 16)) & 0xffff;
        vec4 col = vec4(sin(h * .1) * .5 + .5, sin(h * .3) * .5 + .5, sin(h * .5) * .5 + .5, 1);
        imageStore(output_image, ivec2(gl_GlobalInvocationID.xy), col);
        return;
    }

    vec3 delta = 1./max(abs(dir.xyz), 1e-1);

    HashMapEntry cur_entry;
    cur_entry.key.x = box_unused;
    bool error = false;
    for(int i = 0; i < 500 && inside_aabb(p.xyz, b_min, b_max); ++i){
        float cur_delta = constants.c.delta_grid;
        // ---------------------------------------------------
        // loading the bucket information
        // ---------------------------------------------------
        ivec3 cur_bucket = bucket_pos(p.xyz, constants.c.delta_grid);
        // check if the bucket has to be reload
        if(cur_bucket != cur_entry.key){
            uint h = hash(cur_bucket);
            uint index = (h, constants.c.hash_map_size);
            cur_entry.key = hash_map.d[index].key;
            cur_entry.next = hash_map.d[index].next;
            for(int j = 0; j < 10 && cur_entry.key != cur_bucket && cur_entry.next != uint(-1); ++j){
                index = cur_entry.next;
                cur_entry.key = hash_map.d[cur_entry.next].key;
                cur_entry.next = hash_map.d[cur_entry.next].next;
            }
            if(error) break;
            // loading the rest of the hash map info
            cur_entry.occupancy = hash_map.d[index].occupancy;
            cur_entry.data_index = hash_map.d[index].data_index;
        }

        // ---------------------------------------------------
        // checking for the contents fo the current voxel
        // ---------------------------------------------------

        // if cur_entry still is not for the current grid pos we have an empty grid
        // and can advance to the next hash bucket pos (so skipping to the next bucket pos)
        if(cur_entry.key != cur_bucket){
            cur_delta = hash_bucket_delta;
        }
        else{ // check for used bucket pos
            vec3 bucket_base = bucket_base(cur_bucket, constants.c.delta_grid);
            if(check_bit(cur_entry, bucket_base, p.xyz, constants.c.delta_grid)){
                // bit set, writeout depth and return, nothing more to do
                if(show_iteration_count)
                    imageStore(output_image, ivec2(gl_GlobalInvocationID.xy), vec4(.01) * i);
                else{
                    uint col = data.d[cur_entry.data_index].col;
                    vec4 color = vec4(((col >> 24) & 0xff) / 255., ((col >> 16) & 0xff) / 255., ((col >> 8) & 0xff) / 255., 1.);
                    imageStore(output_image, ivec2(gl_GlobalInvocationID.xy), color);
                }
                return;
            }
        }
        
        // ---------------------------------------------------
        // updating p via DDA
        // ---------------------------------------------------
        p.xyz += calc_t(p.xyz, dir.xyz, delta, 1 / cur_delta) * dir.xyz;
    }
    if(error){
        imageStore(output_image, ivec2(gl_GlobalInvocationID.xy), vec4(1,0,0,1));
        return; }
    imageStore(output_image, ivec2(gl_GlobalInvocationID.xy), vec4(0));
}
