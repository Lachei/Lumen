#version 460
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require
#extension GL_KHR_shader_subgroup_arithmetic : enable
#extension GL_EXT_shader_atomic_int64 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable
#include "pcr_commons.h"

layout(local_size_x = shader_atomic_size_x) in;

layout(push_constant) uniform _PC { PC pc; };
layout(buffer_reference, scalar) buffer ConstantInfos { ShaderAtomic c; };
layout(buffer_reference, scalar) buffer Vertices { vec3 d[]; };
layout(buffer_reference, scalar) buffer Colors   { uint d[]; };
layout(buffer_reference, scalar) buffer Depths   { uint64_t d[]; }; // uint64_t to be able to hold depth and color values in a single buffer

ConstantInfos constants = ConstantInfos(pc.info_addr);
Vertices vertices = Vertices(constants.c.positions_addr);
Colors colors = Colors(constants.c.colors_addr);
Depths depths = Depths(constants.c.depth_image_addr);

void main(){
    if(gl_GlobalInvocationID.x >= constants.c.point_count)
        return;
    
    uint x = gl_GlobalInvocationID.x % pc.size_x;
    uint y = gl_GlobalInvocationID.x / pc.size_x;

    // only loading the position, color only needed when depth is really written out
    vec4 p = vec4(vertices.d[gl_GlobalInvocationID.x].xyz, 1);
    vec3 world_pos = p.xyz;
    p = pc.cam_matrix * p;
    p /= p.w;
    
    // no runtime difference between the two following tests
    //if(p.x < -1 || p.x > 1 ||
    //   p.y < -1 || p.y > 1)
    vec3 clamped = clamp(p.xyz, vec3(-1), vec3(1));
    if(clamped != p.xyz)
        return;

    p.xyz = p.xyz * .5 + .5;
    ivec2 pixel_pos = ivec2(p.xy * vec2(pc.size_x, pc.size_y) + .5f);

    uint64_t depth = floatBitsToUint(1 - p.z);  // inverting the depth value as the buffer is filled with 0
    uint64_t depth_color = depth << 32;

#ifndef RENDER_SPLATS
    uint lin_pos = pixel_pos.x + pixel_pos.y * pc.size_x;

    if(depth_color > depths.d[lin_pos]){
        //vec3 col = colors.d[gl_GlobalInvocationID.x];
        //depth_color |= uint(col.x * 255) << 24;
        //depth_color |= uint(col.y * 255) << 16;
        //depth_color |= uint(col.z * 255) << 8;
        depth_color |= colors.d[gl_GlobalInvocationID.x];
        atomicMax(depths.d[lin_pos], depth_color);
    }
#else
    // calculating the pixel footprint and going through all pixels to check for rendering
    float d = distance(pc.cam_view_inv[3].xyz, world_pos);
    int pixel_footprint = int(8 * .5 * 3.14 / d + .5); // approximate 45^ fov
    pixel_footprint = min(pixel_footprint, 20);
    int pixel_foot_2 = pixel_footprint * pixel_footprint;
    for (int i = -pixel_footprint; i <= pixel_footprint; ++i) {
        int j_foot = int(sqrt(float(pixel_foot_2 - i * i)) + .5);
        for (int j = -j_foot; j <= j_foot; ++j) {
            ivec2 cur_pos = pixel_pos + ivec2(i, j);
            ivec2 clamped_pos = clamp(cur_pos, ivec2(0), ivec2(pc.size_x, pc.size_y));
            if(cur_pos != clamped_pos)
                continue;
            uint lin_pos = cur_pos.x + cur_pos.y * pc.size_x;

            if(depth_color > depths.d[lin_pos]){
                //vec3 col = colors.d[gl_GlobalInvocationID.x];
                //depth_color |= uint(col.x * 255) << 24;
                //depth_color |= uint(col.y * 255) << 16;
                //depth_color |= uint(col.z * 255) << 8;
                depth_color |= colors.d[gl_GlobalInvocationID.x];
                atomicMax(depths.d[lin_pos], depth_color);
            }
        }
    }
#endif
}
