#version 460
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require
#extension GL_KHR_shader_subgroup_arithmetic : enable
#include "../commons.h"
layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0) readonly buffer PostDesc_ { PostDesc post_desc; };
layout(binding = 1, scalar) buffer FFT_Read { vec2 fft_read[]; };
layout(binding = 2, scalar) buffer FFT_Write { vec2 fft_write[]; };
layout(push_constant) uniform PC { FFTPC pc; };
#define PI 3.14159265359

vec2 complex_mul(vec2 a, vec2 b) {
    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

void main() {
    const uint j = gl_GlobalInvocationID.x;
    const uint stride = 1 << pc.idx;
    const uint m = pc.n >> 1;
    if(j >= m) {
        return;
    }
    uint stride_factor = stride * uint(j / stride);
    const float angle = 2 * PI * stride_factor / pc.n;
    vec2 wp = vec2(cos(angle), -sin(angle));

    
    const vec2 a = fft_read[j];
    const vec2 b = fft_read[j + m];
    const uint fixed_idx = j % stride + (stride_factor << 1);
   
    fft_write[fixed_idx] = a + b;
    fft_write[fixed_idx + stride] = complex_mul(wp, a - b);
}