#version 460
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require
#extension GL_KHR_shader_subgroup_arithmetic : enable
#extension GL_EXT_shader_atomic_int64 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable
#extension GL_EXT_control_flow_attributes: enable

#include "mvm_commons.h"

layout(binding = 0, rgba32f) uniform image2D output_image;
layout(binding = 1) uniform sampler2D textures[];
layout(local_size_x = workgroup_size_x, local_size_y = workgroup_size_y) in;

layout(push_constant) uniform _PC { PC pc;};
layout(buffer_reference, scalar) buffer MultiViewInfos { MultiViewInfo d[]; };

MultiViewInfos multi_view_infos = MultiViewInfos(pc.multi_view_infos_addr);

// intersects the ray given as origin and direction with the view frustrum at the given index
// return the entry and exit lambda (position can be retrieved via: p = ray_start + lambda * ray_dir)
// if entry lambda > exit lambda no intersection
vec2 frustrum_intersection(vec3 ray_start, vec3 ray_dir, int view){
    vec2 lambdas = vec2(-1./0., 1./0.);

    [[unroll]]
    for (int face = 0; face < 6; ++face) {
        // load face parameters
        vec3 s_face;
        if (face == 0 || face == 2 || face == 3)
            s_face = multi_view_infos.d[view].p1.xyz;
        else
            s_face = multi_view_infos.d[view].p2.xyz;
        
        vec3 normal;
        switch(face){
        case 0: normal = multi_view_infos.d[view].n0.xyz; break;
        case 1: normal = multi_view_infos.d[view].n1.xyz; break;
        case 2: normal = multi_view_infos.d[view].n2.xyz; break;
        case 3: normal = multi_view_infos.d[view].n3.xyz; break;
        case 4: normal = multi_view_infos.d[view].n4.xyz; break;
        case 5: normal = -multi_view_infos.d[view].n0.xyz; break; // the back face is simply the normal swapped
        }
        
        // calculating the intersection
        float lambda = (dot(s_face, normal) - dot(ray_start, normal)) / dot(ray_dir, normal);
        
        // either add to start or end of ray depending on ray orientation
        if (dot(ray_dir, normal) > 0)   // facing the same direction, front
            lambdas[0] = max(lambdas[0], lambda);
        else
            lambdas[1] = min(lambdas[1], lambda);
    }
    return lambdas;
}

void main(){
    if(gl_GlobalInvocationID.x >= pc.size_x || gl_GlobalInvocationID.y >= pc.size_y)
        return;
        
    //uint index = gl_GlobalInvocationID.y * pc.size_x + gl_GlobalInvocationID.x;
    //FVec depth_map = FVec(multi_view_infos.d[0].depth_addr);
    //imageStore(output_image, ivec2(gl_GlobalInvocationID.xy), vec4(depth_map.d[index] / 50));
    //return;

    // calculate starting position and direction
    vec2 norm_dev_coords = (vec2(gl_GlobalInvocationID.xy) + vec2(.5)) / vec2(pc.size_x, pc.size_y) * 2 - 1;
    vec4 origin = pc.cam_view_inv[3]; // 4th column is the origin transformation
    vec4 dir = pc.cam_proj_inv * vec4(norm_dev_coords.x, norm_dev_coords.y, 1, 1);
    float dist = length(dir.xyz);
    dir = pc.cam_view_inv * vec4(normalize(dir.xyz), 0);
    vec4 p = origin + .01 * dist * dir;
    p.w = 1;
    dir.w = 0;
    vec4 color = vec4(0);
    int color_count = 0;
    bool inside = false;
    
    for (int view = 0; view < pc.amt_multi_views; ++view) {
        vec2 intersect = frustrum_intersection(origin.xyz, dir.xyz, view);
        //color = vec4(.1) * intersect.y;
        //break;
        if (intersect.x < intersect.y && intersect.x > 0){
            vec3 p = intersect.x * dir.xyz + origin.xyz;
            ivec3 pi = ivec3(p / 2);
            int v = 2349930122 * pi.x ^ 1918329102 * pi.y ^ 1239093154 * pi.z;
            color.xyz += vec3(abs(sin(.0001 * v)), abs(sin(.0009 * v + .3)), abs(sin(.0003 * v + 1.1)));
            color_count++;
        }
    }
    color /= color_count;
    /*
    for (int i = 0; i < 2000; ++i){
        // going through all views and checking if an intersectoin exists
        // can skip if the a single views depth map is larger than point distance to center
        bool inside_obj = false;
        vec3 col = vec3(0);
        float weight_sum = 0;
        for (int view = 0; view < pc.amt_multi_views; ++view){
            mat4 cam_view_proj = multi_view_infos.d[view].cam_view_proj;
            vec4 pp = cam_view_proj * p;
            pp /= pp.w;
            vec3 xyz = clamp(pp.xyz, vec3(-1), vec3(1));
            if (xyz != pp.xyz)    // not inside view
                continue;

            inside_obj = true;
            vec2 view_size = vec2(multi_view_infos.d[view].size_x, multi_view_infos.d[view].size_y);
            xyz.xy = xyz.xy * .5 + .5;
            vec4 view_center = multi_view_infos.d[view].cam_origin;
            float depth = xyz.z;

            // load image depth for comparison
            float shadow_depth = texture(textures[multi_view_infos.d[view].depth_texture_index], xyz.xy).x;
            if (depth < shadow_depth || isnan(shadow_depth)) {
                inside_obj = false;
                break;
            }
            if(1.f / abs(depth - shadow_depth) > 100){  // 1 / depth_diff is a linear approximation of the equality
                float w = 1 +  dot(-dir.xyz, normalize(view_center.xyz - p.xyz));
                w = pow(w, 12);
                col += w * texture(textures[multi_view_infos.d[view].color_texture_index], xyz.xy).rgb;
                weight_sum += w;
            }
        }

        if (inside_obj) { // color calculation still missing
            color = vec4(col / weight_sum, 1);
            inside = true;
            break;
        }
        p += .02 * dir; // advance position
    }
    */
    //color = inside ? vec4(1,0,0,1): vec4(1);
    //color = vec4(vec3(distance(p, origin) / 100), 1);
    imageStore(output_image, ivec2(gl_GlobalInvocationID.xy), color);
}