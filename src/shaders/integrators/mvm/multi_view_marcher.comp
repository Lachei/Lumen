#version 460
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require
#extension GL_KHR_shader_subgroup_arithmetic : enable
#extension GL_EXT_shader_atomic_int64 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable
#extension GL_EXT_control_flow_attributes: enable

// --------------------------------------------------
// const settings
// --------------------------------------------------
const bool show_frustrums = true;

#include "mvm_commons.h"

layout(binding = 0, rgba32f) uniform image2D output_image;
layout(binding = 1) uniform sampler2D textures[];
layout(local_size_x = workgroup_size_x, local_size_y = workgroup_size_y) in;

layout(push_constant) uniform _PC { PC pc;};
layout(buffer_reference, scalar) buffer MultiViewInfos { MultiViewInfo d[]; };

MultiViewInfos multi_view_infos = MultiViewInfos(pc.multi_view_infos_addr);

// intersects the ray given as origin and direction with the view frustrum at the given index
// return the entry and exit lambda (position can be retrieved via: p = ray_start + lambda * ray_dir)
// if entry lambda > exit lambda no intersection
vec2 frustrum_intersection(vec3 ray_start, vec3 ray_dir, int view){
    vec2 lambdas = vec2(-1./0., 1./0.);

    [[unroll]]
    for (int face = 0; face < 6; ++face) {
        // load face parameters
        vec3 s_face;
        if (face == 0 || face == 2 || face == 3)
            s_face = multi_view_infos.d[view].p1.xyz;
        else
            s_face = multi_view_infos.d[view].p2.xyz;
        
        vec3 normal;
        switch(face){
        case 0: normal = multi_view_infos.d[view].n0.xyz; break;
        case 1: normal = multi_view_infos.d[view].n1.xyz; break;
        case 2: normal = multi_view_infos.d[view].n2.xyz; break;
        case 3: normal = multi_view_infos.d[view].n3.xyz; break;
        case 4: normal = multi_view_infos.d[view].n4.xyz; break;
        case 5: normal = -multi_view_infos.d[view].n0.xyz; break; // the back face is simply the normal swapped
        }
        
        // calculating the intersection
        float lambda = (dot(s_face, normal) - dot(ray_start, normal)) / dot(ray_dir, normal);
        
        // either add to start or end of ray depending on ray orientation
        if (dot(ray_dir, normal) > 0)   // facing the same direction, front
            lambdas[0] = max(lambdas[0], lambda);
        else
            lambdas[1] = min(lambdas[1], lambda);
    }
    return lambdas;
}

void main(){
    if(gl_GlobalInvocationID.x >= pc.size_x || gl_GlobalInvocationID.y >= pc.size_y)
        return;
        
    //imageStore(output_image, ivec2(gl_GlobalInvocationID.xy), vec4(depth_map.d[index] / 50));
    //return;

    // calculate starting position and direction
    vec2 norm_dev_coords = (vec2(gl_GlobalInvocationID.xy) + vec2(.5)) / vec2(pc.size_x, pc.size_y) * 2 - 1;
    vec4 origin = pc.cam_view_inv[3]; // 4th column is the origin transformation
    vec4 dir = pc.cam_proj_inv * vec4(norm_dev_coords.x, norm_dev_coords.y, 1, 1);
    float dist = length(dir.xyz);
    dir = pc.cam_view_inv * vec4(normalize(dir.xyz), 0);
    vec4 p = origin + .01 * dist * dir;
    p.w = 1;
    dir.w = 0;
    vec4 color = vec4(0);
    int color_count = 0;
    bool inside = false;
    vec3 deepest_point = vec3(1./0.);
    
    /*
    for (int view = 0; view < pc.amt_multi_views; ++view) {
        vec2 intersect = frustrum_intersection(origin.xyz, dir.xyz, view);
        if (intersect.x < intersect.y) {
            vec3 p1 = intersect.x * dir.xyz + origin.xyz;
            vec3 p2 = intersect.y * dir.xyz + origin.xyz;

            if (show_frustrums) {
                ivec3 pi = ivec3(p1 / 2);
                int v = 2349930122 * pi.x ^ 1918329102 * pi.y ^ 1239093154 * pi.z;
                if (intersect.x > 0)
                    color.xyz += vec3(abs(sin(.0001 * v)), abs(sin(.0009 * v + .3)), abs(sin(.0003 * v + 1.1)));
                color_count++;
                continue;
            }

            // getting the start and endpoint inside the view frustrum
            vec4 f_start = multi_view_infos.d[view].cam_view_proj * vec4(p1, 1);
            vec4 f_end = multi_view_infos.d[view].cam_view_proj * vec4(p2, 1);
            f_start /= f_start.w;
            f_start = f_start * .5 + .5;
            f_end /= f_end.w;
            f_end = f_end * .5 + .5;
            
            // doing an optimized intersection search with the lod levels
            float cur_alpha = 0;
            vec3 cur_pos = mix(f_start, f_end, .999);
            int cur_mip = multi_view_infos.d[view].mip_texture_count - 1;
            uint mip_base = multi_view_infos.d[view].mip_texture_index;
            for (int safety = 0; safety < 1000; ++safety) {
                float cur = texture(textures[multi_view_infos.d[view].depth_texture_index], cur_pos.xy).z;
                if (cur > cur_pos.z) {
                    if (distance(cur_w_pos.xyz, origin.xyz) < distance(orgin.xyz, deepest_point))
                        deepest_point = cur_w_pos.xyz;
                    break;
                }
                /*
                vec4 cur_w_pos = multi_view_infos.d[view].cam_view_proj_inv * vec4(cur_pos, 1);
                w_pos /= w_pos.w;

                if (cur_mip == -1) {
                    // check in the depth map
                    float cur = texture(textures[multi_view_infos.d[view].depth_texture_index], cur_pos.xy).x;
                    if (cur > cur_pos.z) {
                        if (distance(cur_w_pos.xyz, origin.xyz) < distance(origin.xyz, deepest_point)) {
                            deepest_point = cur_w_pos.xyz;
                        }
                    }

                    continue;
                }

                ivec2 mip_pos = ivec2(cur_pos.xy * (textureSize(textures[mip_base + cur_mip]) - 1) + .5);
                float mip_val = texelFetch(textures[mip_base + cur_mip], mip_pos, 0).x;
                if (mip_val > cur_pos.z)
                    --cur_mip;
                else {
                    // advance to border of mip box

                }
                */
    //        }
    //    }
    //}
    //if (show_frustrums)
    //    color /= color_count;

    for (int i = 0; i < 2000; ++i){
        // going through all views and checking if an intersectoin exists
        // can skip if the a single views depth map is larger than point distance to center
        bool inside_obj = false;
        vec3 col = vec3(0);
        float weight_sum = 0;
        float next_step_size = 1./0.;
        for (int view = 0; view < pc.amt_multi_views; ++view){
            mat4 cam_view_proj = multi_view_infos.d[view].cam_view_proj;
            vec4 pp = cam_view_proj * p;
            pp /= pp.w;
            vec3 xyz = clamp(pp.xyz, vec3(-1), vec3(1));
            if (xyz != pp.xyz) {   // not inside view
                // getting step size to get into this frustrum
                vec2 inter = frustrum_intersection(p.xyz, dir.xyz, view);
                if (inter.x < inter.y && inter.x > 0)
                    next_step_size = min(inter.x + .001, next_step_size);
                continue;
            }
            next_step_size = .01;

            inside_obj = true;
            vec2 view_size = vec2(multi_view_infos.d[view].size_x, multi_view_infos.d[view].size_y);
            xyz.xy = xyz.xy * .5 + .5;
            vec4 view_center = multi_view_infos.d[view].cam_origin;
            float depth = xyz.z;

            // load image depth for comparison
            /*
            uint base_mip = multi_view_infos.d[view].mip_texture_index;
            for (int mip = int(multi_view_infos.d[view].mip_texture_count) - 1; mip >= 0; --mip) {
                ivec2 mip_pos = ivec2(xyz.xy * (textureSize(textures[base_mip + mip], 0) - 1) + .5);
                float mip_depth = texelFetch(textures[base_mip + mip], mip_pos, 0).x;
                if (depth < mip_depth || isnan(mip_depth)) {
                    inside_obj = false;
                    break;
                }
            }
            if (!inside_obj)
                break;
                */
            float shadow_depth = texture(textures[multi_view_infos.d[view].depth_texture_index], xyz.xy).x;
            if (depth < shadow_depth || isnan(shadow_depth)) {
                inside_obj = false;
                break;
            }
            if(1.f / abs(depth - shadow_depth) > 51){  // 1 / depth_diff is a linear approximation of the equality
                float w = 1 +  dot(-dir.xyz, normalize(view_center.xyz - p.xyz));
                w = pow(w, 12);
                col += w * texture(textures[multi_view_infos.d[view].color_texture_index], xyz.xy).rgb;
                weight_sum += w;
            }
        }

        if (inside_obj) { // color calculation still missing
            color = vec4(col / weight_sum, 1);
            inside = true;
            break;
        }
        if (isinf(next_step_size))
            break;
        p += next_step_size * dir; // advance position
    }
    //color = inside ? vec4(1,0,0,1): vec4(1);
    //color = vec4(vec3(distance(p, origin) / 100), 1);
    imageStore(output_image, ivec2(gl_GlobalInvocationID.xy), color);
}