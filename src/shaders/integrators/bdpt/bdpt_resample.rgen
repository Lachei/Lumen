#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require

#include "../../commons.glsl"
layout(push_constant) uniform _PushConstantRay { PCBDPT pc_ray; };
// BDPT buffers
layout(buffer_reference, scalar) buffer LightVertices { PathVertex d[]; };
layout(buffer_reference, scalar) buffer CameraVertices { PathVertex d[]; };
layout(buffer_reference, scalar) buffer ColorStorages { vec3 d[]; };
layout(buffer_reference, scalar) buffer LightResampledReservoirs { LightResampleReservoir d[]; };

LightVertices light_verts = LightVertices(scene_desc.light_path_addr);
CameraVertices camera_verts = CameraVertices(scene_desc.camera_path_addr);
ColorStorages tmp_col = ColorStorages(scene_desc.color_storage_addr);
LightResampledReservoirs light_resampled_reservoirs = LightResampledReservoirs(scene_desc.global_light_reservoirs_addr);
LightResampledReservoirs light_spatial_reservoirs = LightResampledReservoirs(scene_desc.global_light_spatial_addr);

uint screen_size = gl_LaunchSizeEXT.x * gl_LaunchSizeEXT.y;
uint bdpt_path_idx =
    (gl_LaunchIDEXT.x * gl_LaunchSizeEXT.y + gl_LaunchIDEXT.y) *
    (pc_ray.max_depth + 1);

const uint flags = gl_RayFlagsOpaqueEXT;
const float tmin = 0.001;
const float tmax = 10000.0;
#define RR_MIN_DEPTH 3
uint pixel_idx = (gl_LaunchIDEXT.x * gl_LaunchSizeEXT.y + gl_LaunchIDEXT.y);
uvec4 seed = init_rng(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy,
                      pc_ray.frame_num ^ pc_ray.time);
#include "../bdpt_commons.glsl"
#include "../bdpt_resampling_commons.glsl"

// ------------------------------------------------------------------------------------------
// custom resampling code
// ------------------------------------------------------------------------------------------

// light reservoirs are as large as the screen buffer, meaning that each pixel
// gets its own reservoir
// This behaviour is different for other types of integrators (see VCMResampled)
const float light_default_weight = .01f; // default weight that is used to combine the new sample with history samples (is only the minimal value, normally the blending factor is chosen according to the amount of samples already in the reservoir)
void resample_light_temporal(inout float light_pdf, inout vec3 pos, inout vec3 dir, inout vec3 n){
    // if no temporal data is available or we should not resample return
    if(pc_ray.frame_num == 0)
        return;

    // load the stored reservoir and add the new sample to it (With a constant weight,
    // the resampling weight dependant on luminance values will be hadled after ray tracing)
    LightResampleReservoir reservoir;
    #ifdef USE_SPATIAL_RESERVOIRS
        load_light_resampled(light_spatial_reservoirs, reservoir);
    #else
        load_light_resampled(light_resampled_reservoirs, reservoir);
    #endif
    float light_weight = 1. / (reservoir.m + 1.);
    light_weight = max(light_weight, light_default_weight);
    reservoir_add_light_sample(reservoir, light_weight, pos, dir, n);
    pos = reservoir.pos;
    dir = reservoir.dir;
    n   = reservoir.n;

    // calculate the resulting pdf/adjust the pdf value
    // reasoning for the new pdf value is as follows
    // light_pdf which is given here as input is the base probability to which the other probabilities
    // have to be multiplied up to retrieve the final probability of choosing this sample.
    // When doing resampling the probability of choosing this final sample is weight/total_weight
    // To account for the amount of probes in the reservoir the pdf has to me multiplied by the count (Otherwise energy would be introduced)
    light_pdf *= float(reservoir.m) * reservoir.w / reservoir.w_sum;
}


// loads the temporal reservoir and adds the current light starting point to the temporal
// reservoir for future reuse
const uint max_samples = 5;
void add_light_to_temporal(float luminance, vec3 pos, vec3 dir, vec3 n){
    LightResampleReservoir reservoir;
    if(pc_ray.frame_num == 0){
        reservoir.w = reservoir.w_sum = 0;
        reservoir.m = 0;
    }
    else{
        load_light_resampled(light_resampled_reservoirs, reservoir);
    }
    // TODO maybe recheck
    luminance = clamp(luminance, .1, 10);   // avoiding bias
    reservoir_add_light_sample(reservoir, luminance, pos, dir, n);

    // reducing the maximmum amount of samples stored temporally to avoid numerical problems
    if(false && reservoir.m > max_samples){
        uint prev_m = reservoir.m;
        reservoir.m = max_samples;
        reservoir.w_sum *= 1. - float(max_samples) / prev_m;
    }

    store_light_resampled(light_resampled_reservoirs, reservoir);
}

// spatial resampling is done now in a preprocess (see bdpt_spatial_resample.comp for details)
void resample_light_spatial(){
}

int bdpt_generate_light_subpath_resampled(const int max_depth, const vec3 cam_origin) {
    LightRecord light_record;
    vec3 wi, pos, n;
    float pdf_pos, pdf_dir = 1;
    float cos_theta = 1;
#if BDPT_MLT == 1
    const vec4 rands_pos =
        vec4(mlt_rand(mlt_seed, large_step), mlt_rand(mlt_seed, large_step),
             mlt_rand(mlt_seed, large_step), mlt_rand(mlt_seed, large_step));
    const vec2 rands_dir =
        vec2(mlt_rand(mlt_seed, large_step), mlt_rand(mlt_seed, large_step));
    const vec3 Le = sample_light_Le(
        pc_ray.num_lights, pc_ray.light_triangle_count, cos_theta, light_record,
        pos, wi, n, pdf_pos, pdf_dir, rands_pos, 1.)
#else
    vec3 Le = sample_light_Le(seed, pc_ray.num_lights, pc_ray.light_triangle_count,
                        cos_theta, light_record, pos, wi, n, pdf_pos, pdf_dir);
    
#endif
    if (pdf_dir <= 0) {
        return 0;
    }
    light_pdf_pos = pdf_pos;

    // only inserting the pdf_pos as input as it incorporates already the light amount correction
    resample_light_temporal(pdf_pos, pos, wi, n);
    cos_theta = max(dot(n, wi), 0);

    light_verts.d[bdpt_path_idx].pos = pos;
    light_verts.d[bdpt_path_idx].light_flags = light_record.flags;
    light_verts.d[bdpt_path_idx].delta = 0;
    light_verts.d[bdpt_path_idx].dir = wi;
    light_verts.d[bdpt_path_idx].pdf_fwd = pdf_pos;
    light_verts.d[bdpt_path_idx].n_s = n;
    vec3 throughput =
        Le * cos_theta / (pdf_dir * light_verts.d[bdpt_path_idx + 0].pdf_fwd);
    light_verts.d[bdpt_path_idx + 0].throughput = Le;
    int num_light_verts =
        bdpt_random_walk_light(max_depth - 1, throughput, pdf_dir) + 1;
    if (!is_light_finite(light_record.flags)) {
        light_verts.d[bdpt_path_idx + 1].pdf_fwd =
            pdf_pos * abs(dot(wi, light_verts.d[bdpt_path_idx + 1].n_s));
    }
    if (is_light_delta(light_record.flags)) {
        light_verts.d[bdpt_path_idx].pdf_fwd = 0;
    }
    return num_light_verts;
}

// ------------------------------------------------------------------------------------------
// main function
// ------------------------------------------------------------------------------------------
void main() {
    const vec2 pixel = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 in_uv = pixel / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = in_uv * 2.0 - 1.0;
    vec4 origin = ubo.inv_view * vec4(0, 0, 0, 1);
    vec4 target = ubo.inv_projection * vec4(d.x, d.y, 1, 1);
    vec3 direction = vec3(sample_camera(d));

    vec3 col = vec3(0);
    vec4 area_int = (ubo.inv_projection * vec4(2. / gl_LaunchSizeEXT.x,
                                               2. / gl_LaunchSizeEXT.y, 0, 1));
    area_int /= (area_int.w);
    const float cam_area = abs(area_int.x * area_int.y);

    int num_light_paths = bdpt_generate_light_subpath_resampled(pc_ray.max_depth + 1, origin.xyz);
    //if(true){
    //    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(light_verts.d[bdpt_path_idx].throughput, 1));
    //    return;
    //}
    int num_cam_paths = bdpt_generate_camera_subpath(
        d, origin.xyz, pc_ray.max_depth + 1, cam_area);
    for (int t = 1; t <= num_cam_paths; t++) {
        for (int s = 0; s <= num_light_paths; s++) {
            int depth = s + t - 2;
            if (depth > (pc_ray.max_depth - 1) || depth < 0 ||
                (s == 1 && t == 1)) {
                continue;
            }
            if (t == 1) {
                ivec2 coords;
                vec3 splat_col = bdpt_connect_cam(s, coords);
                if (luminance(splat_col) > 0) {
                    uint idx = coords.x * gl_LaunchSizeEXT.y + coords.y;
                    tmp_col.d[idx] += splat_col;
                }
            } else {
                col += bdpt_connect(s, t);
            }
        }
    }
    vec3 splat_img = tmp_col.d[pixel_idx];
    col += splat_img;
    tmp_col.d[pixel_idx] = vec3(0);
    
    //col = light_verts.d[bdpt_path_idx].pos;
    //col = vec3(dot(normalize(-light_verts.d[bdpt_path_idx].pos), light_verts.d[bdpt_path_idx].n_s));
    if (camera_verts.d[bdpt_path_idx + 1].light_flags == -1)
        col = shade_atmosphere(pc_ray.dir_light_idx, pc_ray.env_tex_idx, pc_ray.sky_col, origin.xyz, direction, tmax);
    
    if (isnan(luminance(col)))
        col = vec3(0);
    
    if (pc_ray.frame_num > 0) {
        float w = 1. / float(pc_ray.frame_num + 1);
        vec3 old_col = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
        // imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(col, 1.f));
        imageStore(image, ivec2(gl_LaunchIDEXT.xy),
                   vec4(mix(old_col, col, w), 1.f));
    } else {
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(col, 1.f));
    }
    //if(reservoir_store_error)
    //    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(1,0,0,1));

    // updating the temporal reservoirs
    add_light_to_temporal(luminance(col), light_verts.d[bdpt_path_idx].pos, light_verts.d[bdpt_path_idx].dir, light_verts.d[bdpt_path_idx].n_s);
}