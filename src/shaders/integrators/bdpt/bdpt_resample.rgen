#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require

#include "../../commons.glsl"
layout(push_constant) uniform _PushConstantRay { PCBDPT pc_ray; };
// BDPT buffers
layout(buffer_reference, scalar) buffer LightVertices { PathVertex d[]; };
layout(buffer_reference, scalar) buffer CameraVertices { PathVertex d[]; };
layout(buffer_reference, scalar) buffer ColorStorages { vec3 d[]; };
layout(buffer_reference, scalar) buffer LightResampledReservoirs { LightResampleReservoir d[]; };

//TODO remove after debugging
layout(buffer_reference, scalar) buffer LightResampledPositions { vec3 d[];};
struct Weights {float w, w_sum, p_h; uint m;};
layout(buffer_reference, scalar) buffer LightResampledWeights { Weights d[];};
LightResampledPositions light_resampled_positions = LightResampledPositions(scene_desc.debug_resample_positions_addr);
LightResampledWeights light_resampled_weights = LightResampledWeights(scene_desc.debug_resample_weights_addr);


LightVertices light_verts = LightVertices(scene_desc.light_path_addr);
CameraVertices camera_verts = CameraVertices(scene_desc.camera_path_addr);
ColorStorages tmp_col = ColorStorages(scene_desc.color_storage_addr);
LightResampledReservoirs light_resampled_reservoirs = LightResampledReservoirs(scene_desc.global_light_reservoirs_addr);
LightResampledReservoirs light_spatial_reservoirs = LightResampledReservoirs(scene_desc.global_light_spatial_addr);



uint screen_size = gl_LaunchSizeEXT.x * gl_LaunchSizeEXT.y;
uint bdpt_path_idx =
    (gl_LaunchIDEXT.x * gl_LaunchSizeEXT.y + gl_LaunchIDEXT.y) *
    (pc_ray.max_depth + 1);

const uint flags = gl_RayFlagsOpaqueEXT;
const float tmin = 0.001;
const float tmax = 10000.0;
#define RR_MIN_DEPTH 3
uint pixel_idx = (gl_LaunchIDEXT.x * gl_LaunchSizeEXT.y + gl_LaunchIDEXT.y);
uvec4 seed = init_rng(gl_LaunchIDEXT.xy, gl_LaunchSizeEXT.xy,
                      pc_ray.frame_num ^ pc_ray.time);
#define BDPT_RESAMPLE
uvec4 light_start_seed;

//TODO remvoe after debugging
vec3 start_pos;
bool same = true;
Weights start_weights;
#include "../bdpt_commons.glsl"
#include "../bdpt_resampling_commons.glsl"

// ------------------------------------------------------------------------------------------
// custom resampling code
// ------------------------------------------------------------------------------------------

// light reservoirs are as large as the screen buffer, meaning that each pixel
// gets its own reservoir
// This behaviour is different for other types of integrators (see VCMResampled)
const float light_default_weight = .001f; // default weight that is used to combine the new sample with history samples (is only the minimal value, normally the blending factor is chosen according to the amount of samples already in the reservoir)
float resample_weight;
bool resample_light_temporal(inout float light_pdf, inout uvec4 seed){
    // if no temporal data is available or we should not resample return
    if(pc_ray.frame_num == 0)
        return false;

    // load the stored reservoir and add the new sample to it (With a constant weight,
    // the resampling weight dependant on luminance values will be hadled after ray tracing)
    LightResampleReservoir reservoir;
    #ifdef USE_SPATIAL_RESERVOIRS
        load_light_resampled(light_spatial_reservoirs, reservoir);
    #else
        load_light_resampled(light_resampled_reservoirs, reservoir);
    #endif
    float light_weight = resample_weight = reservoir.w_sum / float(reservoir.m);
    //light_weight = max(light_weight, light_default_weight);
    if(reservoir.m == 0)
        light_weight = 1;

    // as light_weight can be interpreted as the normalized sampling probability (p_h/p)
    // here we unnormalize light_weight to get an approximate p_h
    const float p_h = light_weight * light_pdf; 

    bool resampled = reservoir_add_light_sample(reservoir, light_weight, seed, p_h);
    seed = reservoir.seed;

    //TODO remove after debugging
    start_weights.w = reservoir.w;
    start_weights.w_sum = reservoir.w_sum;
    start_weights.p_h = reservoir.p_h;
    start_weights.m = reservoir.m;

    //if(resampled)
    //    // if resampled exchange the p_h value stored in the w component of the reservoir
    //    // p_h can be retrieved from teh light_weight as light_weight was chosen such that it would be the average weight for resampling
    //    reservoir.w = light_pdf * light_weight;

    // calculate the resulting pdf/adjust the pdf value
    // reasoning for the new pdf value is as follows
    // light_pdf which is given here as input is the base probability to which the other probabilities
    // have to be multiplied up to retrieve the final probability of choosing this sample.
    // When doing resampling the probability of choosing this final sample is weight/total_weight
    // To account for the amount of probes in the reservoir the pdf has to me multiplied by the count (Otherwise energy would be introduced)
    light_pdf = reservoir.p_h * reservoir.m / reservoir.w_sum;
    //light_pdf *= reservoir.m * reservoir.w / reservoir.w_sum;
    return resampled;
}


// loads the temporal reservoir and adds the current light starting point to the temporal
// reservoir for future reuse
const uint max_samples = 20;
void add_light_to_temporal(float luminance, float sampling_pdf, uvec4 seed){
    LightResampleReservoir reservoir;
    if(pc_ray.frame_num == 0){
        reservoir.w = reservoir.w_sum = 0;
        reservoir.m = 0;
    }
    else{
        load_light_resampled(light_resampled_reservoirs, reservoir);
    }
    // TODO maybe recheck
    luminance = clamp(luminance, .001, 100);   // avoiding bias
    if(luminance < .01) { // small luminances are simply ignored to avoid bias
        store_light_resampled(light_resampled_reservoirs, reservoir);   
        return;
    }
    
    const float p_h = luminance * sampling_pdf; // the luminance is the integral evaluated at the sample normalized by the sampling probability. So this unnormalizes the luminance to the target function
    reservoir_add_light_sample(reservoir, luminance, seed, p_h);

    // reducing the maximmum amount of samples stored temporally to avoid numerical problems
    if(reservoir.m > max_samples){
        uint prev_m = reservoir.m;
        reservoir.m = max_samples;
        reservoir.w_sum *= float(max_samples) / prev_m;
    }

    store_light_resampled(light_resampled_reservoirs, reservoir);
}

// spatial resampling is done now in a preprocess (see bdpt_spatial_resample.comp for details)
void resample_light_spatial(){
}

int bdpt_generate_light_subpath_resampled(const int max_depth, const vec3 cam_origin, out bool resampled) {
    light_start_seed = seed;
    
    LightRecord light_record;
    vec3 wi, pos, n;
    float pdf_pos, pdf_dir = 1;
    float cos_theta = 1;
#if BDPT_MLT == 1
    const vec4 rands_pos =
        vec4(mlt_rand(mlt_seed, large_step), mlt_rand(mlt_seed, large_step),
             mlt_rand(mlt_seed, large_step), mlt_rand(mlt_seed, large_step));
    const vec2 rands_dir =
        vec2(mlt_rand(mlt_seed, large_step), mlt_rand(mlt_seed, large_step));
    const vec3 Le = sample_light_Le(
        pc_ray.num_lights, pc_ray.light_triangle_count, cos_theta, light_record,
        pos, wi, n, pdf_pos, pdf_dir, rands_pos, 1.)
#else
    vec3 Le = sample_light_Le(seed, pc_ray.num_lights, pc_ray.light_triangle_count,
                        cos_theta, light_record, pos, wi, n, pdf_pos, pdf_dir);
    
#endif

    // only inserting the pdf_pos as input as it incorporates already the light amount correction
    // resampled is true if the current seed is picked, false else
    resampled = resample_light_temporal(pdf_pos, light_start_seed);
    uvec4 seed_copy = light_start_seed;
    float dummy;
    if(!resampled)   // resample but dont override the pdf_pos as it was set in resample_light_temporal(...), thus insert dummy for pdf_light
        Le = sample_light_Le(seed_copy, pc_ray.num_lights, pc_ray.light_triangle_count,
                        cos_theta, light_record, pos, wi, n, dummy, pdf_dir);

    start_pos = pos;
    
    if (pdf_dir <= 0) {
        return 0;
    }

    float pdf_light = pdf_pos;// * pdf_dir;
    light_pdf_pos = pdf_light;//pdf_pos;

    light_verts.d[bdpt_path_idx].pos = pos;
    light_verts.d[bdpt_path_idx].light_flags = light_record.flags;
    light_verts.d[bdpt_path_idx].delta = 0;//uint(is_light_delta(light_record.flags));
    light_verts.d[bdpt_path_idx].dir = wi;
    light_verts.d[bdpt_path_idx].pdf_fwd = pdf_light;//pdf_pos;
    light_verts.d[bdpt_path_idx].n_s = n;
    vec3 throughput =
        Le * cos_theta * pc_ray.num_lights / (pdf_pos * pdf_dir);
    light_verts.d[bdpt_path_idx + 0].throughput = Le;
    int num_light_verts = bdpt_random_walk_light(max_depth - 1, throughput, pdf_dir) + 1;
    
    if (!is_light_finite(light_record.flags)) {
        light_verts.d[bdpt_path_idx + 1].pdf_fwd =
            pdf_pos * abs(dot(wi, light_verts.d[bdpt_path_idx + 1].n_s));
    }
    
    if (is_light_delta(light_record.flags)) {
        light_verts.d[bdpt_path_idx].pdf_fwd = 0;
    }
    return num_light_verts;
}

// ------------------------------------------------------------------------------------------
// main function
// ------------------------------------------------------------------------------------------
void main() {
    const vec2 pixel = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    const vec2 in_uv = pixel / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = in_uv * 2.0 - 1.0;
    vec4 origin = ubo.inv_view * vec4(0, 0, 0, 1);
    vec4 target = ubo.inv_projection * vec4(d.x, d.y, 1, 1);
    vec3 direction = vec3(sample_camera(d));

    vec3 col = vec3(0);
    vec4 area_int = (ubo.inv_projection * vec4(2. / gl_LaunchSizeEXT.x,
                                               2. / gl_LaunchSizeEXT.y, 0, 1));
    area_int /= (area_int.w);
    const float cam_area = abs(area_int.x * area_int.y);

    bool resampled;
    int num_light_paths = bdpt_generate_light_subpath_resampled(pc_ray.max_depth + 1, origin.xyz, resampled);

    int num_cam_paths = bdpt_generate_camera_subpath(
        d, origin.xyz, pc_ray.max_depth + 1, cam_area);
    for (int t = 1; t <= num_cam_paths; t++) {
        for (int s = 0; s <= num_light_paths; s++) {
            int depth = s + t - 2;
            if (depth > (pc_ray.max_depth - 1) || depth < 0 ||
                (s == 1 && t == 1)) {
                continue;
            }
            if (t == 1) {
                ivec2 coords;
                vec3 splat_col = bdpt_connect_cam(s, coords);
                if (luminance(splat_col) > 0) {
                    uint idx = coords.x * gl_LaunchSizeEXT.y + coords.y;
                    tmp_col.d[idx] += splat_col;
                }
            } else {
                col += bdpt_connect(s, t);
            }
        }
    }
    vec3 splat_img = tmp_col.d[pixel_idx];
    col += splat_img;
    tmp_col.d[pixel_idx] = vec3(0);
    
    //col = light_verts.d[bdpt_path_idx].pos;
    //col = vec3(dot(normalize(-light_verts.d[bdpt_path_idx].pos), light_verts.d[bdpt_path_idx].n_s));
    if (camera_verts.d[bdpt_path_idx + 1].light_flags == -1)
        col = shade_atmosphere(pc_ray.dir_light_idx, pc_ray.env_tex_idx, pc_ray.sky_col, origin.xyz, direction, tmax);
    
    if (isnan(luminance(col)))
        col = vec3(0);

    //if(!same)
    //    col = vec3(1, 0  , 0);
    
    if (pc_ray.frame_num > 0) {
        float w = 1. / float(pc_ray.frame_num + 1);
        vec3 old_col = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;
        // imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(col, 1.f));
        imageStore(image, ivec2(gl_LaunchIDEXT.xy),
                   vec4(mix(old_col, col, w), 1.f));
    } else {
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(col, 1.f));
    }

    // updating the temporal reservoirs
    //if(!resampled)
        add_light_to_temporal(luminance(col), light_pdf_pos, light_start_seed);

    //TODO remove after debugging
    light_resampled_positions.d[pixel_idx] = start_pos;
    light_resampled_weights.d[pixel_idx] = start_weights;
}