#version 460
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require
#extension GL_KHR_shader_subgroup_arithmetic : enable

#include "../../utils.glsl"

layout(push_constant) uniform _PushConstantRay { PCPath pc_ray; };
uint pixel_count = pc_ray.size_x * pc_ray.size_y;
uint pixel_x = gl_GlobalInvocationID.x / pc_ray.size_y;
uint pixel_y = gl_GlobalInvocationID.x % pc_ray.size_y;
uint pixel_idx = gl_GlobalInvocationID.x;
uvec4 seed = init_rng(uvec2(pixel_x, pixel_y), uvec2(pc_ray.size_x, pc_ray.size_y), pc_ray.frame_num);

#include "../bdpt_resampling_commons.glsl"

layout(buffer_reference, scalar) buffer LightResampledReservoirs { LightResampleReservoir d[]; };
layout(binding = 0) buffer SceneDesc_ { SceneDesc scene_desc; };

// do not store or load data from these arrays with standard LightREsampleReservoir a = array.d[idx]
// this will lead to erroneous loading due to alignment mismatches with the registers
// use load/store_lgiht_resampled[_idx] instead (see bdpt_resampling_commons.glsl for implementation)
LightResampledReservoirs light_temporal_reservoirs = LightResampledReservoirs(scene_desc.global_light_reservoirs_addr);
LightResampledReservoirs light_spatial_reservoirs = LightResampledReservoirs(scene_desc.global_light_spatial_addr);

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;


#define pixel_xy2idx(x, y) (x) * pc_ray.size_y + (y)

// In this shader multiple temporal reservoirs of neighbours are used to resample the best sample / approximate the true 
// uminance even better
// One pass uses the 8 neighbours of the current pixel to better approximate
// the underlying luminance, repeating this kernel multiple times results in a larger influence radius
const int max_mult = 20;
void main(){
    if(pixel_idx >= pixel_count)
        return;
    LightResampleReservoir cur_reservoir;
    load_light_resampled(light_temporal_reservoirs, cur_reservoir);

    int mult = int(rand(seed) * max_mult) + 1;

    for(int i = -mult; i <= mult; i += mult){
        for(int j = -mult; j <= mult; j += mult){
            if((i == 0 && j == 0) || pixel_x + i < 0 || pixel_x + i >= pc_ray.size_x ||
                pixel_y + j < 0 || pixel_y + j >= pc_ray.size_y)
                continue;
            const uint idx = pixel_xy2idx(pixel_x + i, pixel_y + j);
            LightResampleReservoir neighbour;
            load_light_resampled_idx(light_temporal_reservoirs, neighbour, idx);
            reservoirs_combine(cur_reservoir, neighbour);
        }
    }

    store_light_resampled(light_spatial_reservoirs, cur_reservoir);
}